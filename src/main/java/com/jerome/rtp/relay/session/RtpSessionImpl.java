package com.jerome.rtp.relay.session;import java.net.InetSocketAddress;import java.util.Iterator;import java.util.Map;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import org.glassfish.grizzly.nio.transport.UDPNIOServerConnection;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.google.common.collect.Sets;import com.jerome.rtp.protocol.data.CompoundControlPacket;import com.jerome.rtp.protocol.data.DataPacket;import com.jerome.rtp.protocol.utils.TimeUtil;import com.jerome.rtp.protocol.utils.TrueRandom;/** * RTP会话（RTP session）:一群参与者通过RTP进行通信时所产生的关联。一个参与者可能同时参与多个RTP会话.在一个多媒体会话中, * 除非编码方式把多种媒体多路复用到一个单一数据流中 * ,否则每种媒体都将使用各自的RTCP包,通过单独的RTP会话来传送.通过使用不同的目的传输地址对(一个网络地址加上一对分别用于RTP和RTCP的端口 * ,构成了一个传输地址对 * )来接收不同的会话，参与者能把多个RTP会话区隔开来.单个RTP会话中的所有参与者,可能共享一个公用目的传输地址对,比如IP多播的情况 * ;也可能各自使用不同的目的传输地址对 * ,比如个体单播网络地址加上一个端口对.对于单播的情况,参与者可能使用相同端口对来收听其他所有参与者,也可能对来其他每个参与者使用不同的端口对来收听. *  * @author Will.jingmiao * @version 创建时间：2014-5-27 下午4:38:32 类说明 */class RtpSessionImpl extends AbstractControlPacketHandler implements RtpSession {	public static final Logger logger = LoggerFactory.getLogger(RtpSessionImpl.class);	private UDPNIOServerConnection dataConnection = null;	private UDPNIOServerConnection controlConnection = null;	private final Set<InetSocketAddress> dataAddress = Sets.newConcurrentHashSet();	private final Map<InetSocketAddress, Participant> controlAddress = new ConcurrentHashMap<InetSocketAddress, Participant>();	private int port;		private long sessionId = TrueRandom.rand();		private long expire;	private boolean isStart=false;		private SessionListener listener;	protected RtpSessionImpl(UDPNIOServerConnection dataConnection, UDPNIOServerConnection controlConnection) {		this.dataConnection = dataConnection;		this.controlConnection = controlConnection;		isStart=true;	}	public void setRtpPort(int rtpPort) {		this.port = rtpPort;	}		public long getSessionId() {		return sessionId;	}	//****************************** RtpSession 实现 , 对外暴露接口. ******************************	@Override	public int getRtpPort() {		return port;	}		@Override	public UDPNIOServerConnection getDataConnect() {		return dataConnection;	}	@Override	public UDPNIOServerConnection getControlConnect() {		return controlConnection;	}		@Override	public long getLastSessionTime() {		return expire;	}		@Override	public void setSessionListener(SessionListener listener) {		this.listener=listener;	}	@Override	SessionListener getListener() {		if(listener==null){			listener = new SessionListener() {				public void dataFilter(InetSocketAddress localAddress, InetSocketAddress remoteAddress, DataPacket packet)						throws SessionExecption {				}				public void controlFilter(InetSocketAddress localAddress, InetSocketAddress remoteAddress,						CompoundControlPacket packet) throws SessionExecption {				}			};		}		return listener;	}		//*************************************** 实现父类方法  ******************************************		//==========================刷新映射地址==========================	@Override	void refreshControlAddress(InetSocketAddress remoteAddress, long ssrc) {		if (!controlAddress.containsKey(remoteAddress)) {			synchronized (this) {				if (!controlAddress.containsKey(remoteAddress)) {					logger.info("##### Rtcp Session Remote[{}] Connect to Localhost Port[{}] .", remoteAddress, this.getRtpPort()+1);					controlAddress.put(remoteAddress, new Participant());				}			}		}		// 更新ssrc		controlAddress.get(remoteAddress).setSsrc(ssrc);		expire=TimeUtil.now();	}	@Override	void refreshDataAddress(InetSocketAddress remoteAddress) {		if (!dataAddress.contains(remoteAddress)) {			synchronized (this) {				if (!dataAddress.contains(remoteAddress)) {					logger.info("##### Rtp Session Remote[{}] Connect to Localhost Port[{}] .",remoteAddress,this.getRtpPort());					dataAddress.add(remoteAddress);				}			}		}		expire=TimeUtil.now();	}	//==========================获取映射地址==========================	@Override	Iterator<InetSocketAddress> getDataAddress() {		return dataAddress.iterator();	}	@Override	Iterator<InetSocketAddress> getControlAddress() {		return controlAddress.keySet().iterator();	}		//==========================操作指定rtcp control info数据.包括获取,删除.==========================	@Override	Participant getRtcpControl(InetSocketAddress address) {		return controlAddress.get(address);	}	@Override	Participant removeRtcpControl(InetSocketAddress address) {		return controlAddress.remove(address);	}	public boolean isStart() {		return isStart;	}	public void stop() {		this.isStart = false;	}}
package com.jerome.rtp.relay.session;import java.net.InetSocketAddress;import java.net.SocketAddress;import java.util.Iterator;import java.util.List;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.google.common.collect.Lists;import com.jerome.rtp.protocol.ControlPacketHandler;import com.jerome.rtp.protocol.data.ByePacket;import com.jerome.rtp.protocol.data.CompoundControlPacket;import com.jerome.rtp.protocol.data.ControlPacket;import com.jerome.rtp.protocol.data.ReceiverReportPacket;import com.jerome.rtp.protocol.data.ReceptionReport;import com.jerome.rtp.protocol.data.SenderReportPacket;/** *  * 抽象实现control分发逻辑. *  * @author Will.jingmiao * @version 创建时间：2014-5-28 下午2:43:46 类说明 */abstract class AbstractControlPacketHandler extends AbstractDataPacketHandler implements ControlPacketHandler {	private static final Logger logger = LoggerFactory.getLogger("**Write Control**");	@Override	public void handleReadControl(InetSocketAddress localAddress, InetSocketAddress remoteAddress,			CompoundControlPacket packet, long ssrc) {		refreshControlAddress(remoteAddress, ssrc);		// 发包		try{			getListener().controlFilter(localAddress,remoteAddress,packet);		}catch (SessionExecption e) {			logger.warn("user filter",e);			return;		}		// 1.查看control包		List<ControlPacket> controlPackets = packet.getControlPackets();		List<Long> ssrcs = Lists.newArrayList();		long sourceSsrc = -1;		boolean isBye = false;		ControlPacket.Type type = ControlPacket.Type.RECEIVER_REPORT;		// 每个RTCP复合包必须以SR或RR包开头		for (ControlPacket controlPacket : controlPackets) {			if (controlPacket instanceof SenderReportPacket) {				type = ControlPacket.Type.SENDER_REPORT;				// 将sr rtcp发送给每个接受者.				sendReportPacket(localAddress, remoteAddress, packet);				return;			} else if (controlPacket instanceof ReceiverReportPacket) {				ReceiverReportPacket rr = (ReceiverReportPacket) controlPacket;				sourceSsrc = rr.getSenderSsrc();				List<ReceptionReport> receptionReports = rr.getReceptionReports();				if (receptionReports == null) {					continue;				}				for (ReceptionReport receptionReport : receptionReports) {					ssrcs.add(receptionReport.getSsrc());				}			} else if (controlPacket instanceof ByePacket) {				type = ControlPacket.Type.BYE;				isBye = true;			}		}		// 找到指定对端发送.		Iterator<InetSocketAddress> iterator = getControlAddress();		while (iterator.hasNext()) {			InetSocketAddress address = iterator.next();			Participant rtcp = getRtcpControl(address);			if (isBye || ssrcs.contains(rtcp.getSsrc())) {				logger.info("Source={} Destination={} RTCP Length={} info={}", getControlConnect().getLocalAddress(),						address, packet.getControlPackets().size(), type);				getControlConnect().write(address, packet, null);			} else if (isBye && sourceSsrc == rtcp.getSsrc()) {				removeRtcpControl(address);			}		}	}	private void sendReportPacket(InetSocketAddress localAddress, SocketAddress remoteAddress,			CompoundControlPacket packet) {		Iterator<InetSocketAddress> iterator = getControlAddress();		while (iterator.hasNext()) {			InetSocketAddress address = iterator.next();			if (!address.equals(remoteAddress)) {				logger.info("Source={} Destination={} RTCP Length={} info={}", getControlConnect().getLocalAddress(),						address, packet.getControlPackets().size(), ControlPacket.Type.SENDER_REPORT);				getControlConnect().write(address, packet, null);			}		}	}	/**	 * 子类实现 对于次连接的刷新逻辑	 * 	 * @param remoteAddress	 * @param ssrc	 */	abstract void refreshControlAddress(InetSocketAddress remoteAddress, long ssrc);	/**	 * 获取rtcp地址映射.	 * 	 * @return	 */	abstract Iterator<InetSocketAddress> getControlAddress();	/**	 * 获取rtcp指定地址信息.	 * 	 * @param address	 * @return	 */	abstract Participant getRtcpControl(InetSocketAddress address);	/**	 * 删除rtcp指定地址信息.	 * 	 * @param address	 * @return	 */	abstract Participant removeRtcpControl(InetSocketAddress address);}
package com.jerome.rtp.relay.utils;/** * 系统端口分配<br> *  * 将端口以BLOCKSIZE=500分区. * 对每个分区进行遍历,当整个分区全部占用,crossOff切换至下一分区. *  * 循环遍历. *  * 只对单一分区进行遍历,增加效率. * *  * @author Will.jingmiao * */public class SysPortUtil {	public static final int UNIT = 2;	public static final int BLOCKSIZE = 500;	private static SysPortUtil instance;		int start;//起端口号	int end;//始端口号	int crossOff = 0;	private boolean[][] blocks;	private SysPortUtil(int start, int end) {		this.start = start;		this.end = end;		int length = (end - start) / (BLOCKSIZE);		if (length == 0) {			blocks = new boolean[1][(end - start) / UNIT];		} else {			blocks = new boolean[length][BLOCKSIZE / UNIT];		}	}	public synchronized int[] getRangePort() {		int[] rangePort = RangePort();		//如果获取不到从新获取.		if(rangePort==null){			rangePort = RangePort();		}		return rangePort;	}	private synchronized int[] RangePort() {		boolean[] cross = blocks[crossOff];		for (int i = 0; i < cross.length; i++) {			if (!cross[i]) {				int rtp = start + crossOff * BLOCKSIZE + i * 2;				int rtcp = rtp + 1;				cross[i] = true;				return new int[] { rtp, rtcp };			}		}		crossOff = crossOff + 1;		if (crossOff >= blocks.length) {			crossOff = 0;			return null;		}		return getRangePort();	}	public synchronized void release(int rtp) {		int crossOff = (rtp - start) / BLOCKSIZE;		int ordinateOff = rtp - start - crossOff * BLOCKSIZE;		blocks[crossOff][ordinateOff / UNIT] = false;	}	public static SysPortUtil getInstance(int start, int end) {		if (instance == null) {			synchronized (SysPortUtil.class) {				if (instance == null) {					instance = new SysPortUtil(start, end);				}			}		}		return instance;	}	public static SysPortUtil getInstance() {		return instance;	}}
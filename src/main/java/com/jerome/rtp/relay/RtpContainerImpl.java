package com.jerome.rtp.relay;import java.io.IOException;import java.net.InetSocketAddress;import java.util.Map;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.ConcurrentHashMap;import org.glassfish.grizzly.nio.transport.UDPNIOServerConnection;import org.glassfish.grizzly.nio.transport.UDPNIOTransport;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.google.common.base.Preconditions;import com.jerome.rtp.protocol.ControlPacketHandler;import com.jerome.rtp.protocol.DataPacketHandler;import com.jerome.rtp.protocol.data.CompoundControlPacket;import com.jerome.rtp.protocol.data.DataPacket;import com.jerome.rtp.protocol.transfer.ControlReceiveBuilder;import com.jerome.rtp.protocol.transfer.DataReceiveBuilder;import com.jerome.rtp.protocol.utils.TimeUtil;import com.jerome.rtp.relay.session.RtpSession;import com.jerome.rtp.relay.session.RtpSessionFactory;import com.jerome.rtp.relay.utils.SysPortUtil;/** * Rtp Relay Server.<br/> *  * 1.负责创建,维护,释放多媒体会话. 2.绑定端口监听,创建connect连接. 3.设置系统设置. 4.接受所有udp包,进行分发. *  * 整个容易创建两个UDPNIOTransport , 一个负责rtp转发 一个负责rtcp转发. *  *  * @author Will.jingmiao * @version 创建时间：2014-5-27 下午4:37:38 类说明 */class RtpContainerImpl implements ControlPacketHandler, DataPacketHandler, RtpContainer {	private static final Logger logger = LoggerFactory.getLogger(RtpContainerImpl.class);	/* 初始 128 session线程 ,由于ConcurrentHashMap扩容效率低 ,session识别采用本地端口号,单一rtp端口对应一session实例.*/	private final Map<Integer, RtpSession> sessions = new ConcurrentHashMap<Integer, RtpSession>(128);	private static final Timer timer = new Timer("Session Timer Out");	private UDPNIOTransport dataReceive = null;	private UDPNIOTransport controlReceive = null;	private String localhost;	protected RtpContainerImpl(RtpConfigure configure) {		Preconditions.checkNotNull(configure);		localhost = configure.getLocalhost();		Preconditions.checkNotNull(localhost);		SysPortUtil.getInstance(configure.getPortBegin(), configure.getPortEnd());		dataReceive = DataReceiveBuilder.stateless().build(this);		controlReceive = ControlReceiveBuilder.stateless().build(this);		try {			dataReceive.start();			controlReceive.start();		} catch (IOException e) {			throw new RuntimeException(e);		}	}	@Override	public RtpSession createMultimediaSession() {		int[] participantPort = SysPortUtil.getInstance().getRangePort();		// 端口获取失败,所有端口都被占用,程序能扛到多少端口都被占用,绝对不说明是程序性能太好,只可能是端口未释放,bug了!		Preconditions.checkNotNull(participantPort, "Port cannot get form sys.");				if(participantPort.length!=2){			throw new IllegalArgumentException("Port cannot get form sys.");		}		return createMultimediaSession(participantPort[0],participantPort[1]);	}	@Override	public RtpSession createMultimediaSession(int rtp, int rtcp) {		try {			UDPNIOServerConnection dataConnection = dataReceive.bind(rtp);			logger.info("Create rtp session bind rtp port[{}] .", rtp);			UDPNIOServerConnection controlConnection = controlReceive.bind(rtcp);			logger.info("Create rtp session bind rtp port[{}] .", rtcp);			final RtpSession session = RtpSessionFactory.newSession(dataConnection, controlConnection, rtp);			sessions.put(rtp, session);// 根据rtp端口保存session维护,用于删除释放.			timer.schedule(new TimerTask() {				@Override				public void run() {					if (!session.isStart()) {						stopTimer();						return;					}					long time = TimeUtil.now() - session.getLastSessionTime();					if (time > 30 * 1000) {						stopSession(session);						stopTimer();					}				}				private void stopTimer() {					boolean cancel = this.cancel();					logger.info("Session [{}] is TimeOut Stop Timer {}.", session.getSessionId(), cancel);				}			}, 10 * 1000, 10 * 1000);			return session;		} catch (IOException e) {			throw new RuntimeException();		}	}	@Override	public final void stopSession(RtpSession session) {		Preconditions.checkNotNull(session, "Rtp session is Null.");		logger.info("unbind session [{}] and [{}]", session.getDataConnect().getLocalAddress(), session				.getControlConnect().getLocalAddress());		// 1. 释放container维护<port,session>		sessions.remove(session.getRtpPort());		// 2. 解绑 rtp 端口 connect		dataReceive.unbind(session.getDataConnect());		// 3. 解绑 rtcp 端口 connect		controlReceive.unbind(session.getControlConnect());		session.stop();		int rtpPort = session.getRtpPort();		// 4.手动将rtp rctp归还给sys.		SysPortUtil.getInstance().release(rtpPort);	}	/**	 * 数据包交由container层处理 获取对应session,在交由指定session处理.	 */	@Override	public void handleReadData(InetSocketAddress localAddress, InetSocketAddress remoteAddress, DataPacket packet) {		int port = localAddress.getPort();// 获取udp包进口端口号,用来获取session.		RtpSession session = sessions.get(port);		if (session != null) {// 将数据交由指定session处理.			session.handleReadData(localAddress, remoteAddress, packet);		}	}	/**	 * 控制包交由container层处理 获取对应session,在交由指定session处理.	 */	@Override	public void handleReadControl(InetSocketAddress localAddress, InetSocketAddress remoteAddress,			CompoundControlPacket packet, long ssrc) {		int port = localAddress.getPort() - 1;// 获取udp包进口端口号,端口号为rtcp端口,session存储为rtp,顾rtcp-1得到rtp端口.		RtpSession session = sessions.get(port);		if (session != null) {			session.handleReadControl(localAddress, remoteAddress, packet, ssrc);		}	}	/**	 * 获取本机ip.	 * 	 * @return	 */	public String getLocalhost() {		return localhost;	}}
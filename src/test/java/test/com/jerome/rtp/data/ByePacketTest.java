package test.com.jerome.rtp.data;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import org.glassfish.grizzly.Buffer;import org.glassfish.grizzly.memory.ByteBufferManager;import org.glassfish.grizzly.memory.HeapBuffer;import org.junit.Test;import com.jerome.rtp.protocol.data.ByePacket;import com.jerome.rtp.protocol.data.ControlPacket;import com.jerome.rtp.protocol.utils.ByteUtils;public class ByePacketTest {	@Test	public void testDecode() throws Exception {		byte[] packetBytes = ByteUtils.convertHexStringToByteArray("81cb0001e6aa996e");		Buffer buffer = HeapBuffer.wrap(packetBytes);		ControlPacket controlPacket = ControlPacket.decode(buffer);		assertEquals(ControlPacket.Type.BYE, controlPacket.getType());		ByePacket byePacket = (ByePacket) controlPacket;		assertNotNull(byePacket.getSsrcList());		assertEquals(1, byePacket.getSsrcList().size());		assertEquals(new Long(0xe6aa996eL), byePacket.getSsrcList().get(0));		assertEquals(null, byePacket.getReasonForLeaving());		assertEquals(0, buffer.capacity() - buffer.position());	}	@Test	public void testDecode2() throws Exception {		// wireshark capture, jlibrtp		byte[] packetBytes = ByteUtils.convertHexStringToByteArray("81cb000a4f52eb38156a6c69627274702073617973206279"				+ "6520627965210000000000000000000000000000");		Buffer buffer = HeapBuffer.wrap(packetBytes);		ControlPacket controlPacket = ControlPacket.decode(buffer);		assertEquals(ControlPacket.Type.BYE, controlPacket.getType());		ByePacket byePacket = (ByePacket) controlPacket;		assertNotNull(byePacket.getSsrcList());		assertEquals(1, byePacket.getSsrcList().size());		assertEquals(new Long(0x4f52eb38L), byePacket.getSsrcList().get(0));		assertEquals("jlibrtp says bye bye!", byePacket.getReasonForLeaving());		assertEquals(0, buffer.capacity() - buffer.position());	}	@Test	public void testEncodeDecode() throws Exception {		ByePacket packet = new ByePacket();		packet.addSsrc(0x45);		packet.addSsrc(0x46);		packet.setReasonForLeaving("So long, cruel world.");		ByteBufferManager mm = new ByteBufferManager();		Buffer buffer = packet.encode(mm);		assertEquals(36, buffer.capacity());		System.out.println(ByteUtils.writeArrayAsHex(buffer.array(), true));		assertEquals(0, buffer.capacity() % 4);		buffer.position(0);		ControlPacket controlPacket = ControlPacket.decode(buffer);		assertEquals(ControlPacket.Type.BYE, controlPacket.getType());		ByePacket byePacket = (ByePacket) controlPacket;		assertNotNull(byePacket.getSsrcList());		assertEquals(2, byePacket.getSsrcList().size());		assertEquals(new Long(0x45), byePacket.getSsrcList().get(0));		assertEquals(new Long(0x46), byePacket.getSsrcList().get(1));		assertEquals("So long, cruel world.", byePacket.getReasonForLeaving());		assertEquals(0, buffer.capacity() - buffer.position());	}	@Test	public void testEncodeDecodeWithFixedBlockSize64() throws Exception {		ByePacket packet = new ByePacket();		packet.addSsrc(0x45);		packet.addSsrc(0x46);		packet.setReasonForLeaving("So long, cruel world.");		ByteBufferManager mm = new ByteBufferManager();		Buffer buffer = packet.encode(0, 64, mm);		assertEquals(64, buffer.capacity());		byte[] bufferArray = buffer.array();		System.out.println(ByteUtils.writeArrayAsHex(bufferArray, true));		assertEquals(0, buffer.capacity() % 4);		buffer.position(0);		ControlPacket controlPacket = ControlPacket.decode(buffer);		assertEquals(ControlPacket.Type.BYE, controlPacket.getType());		ByePacket byePacket = (ByePacket) controlPacket;		assertNotNull(byePacket.getSsrcList());		assertEquals(2, byePacket.getSsrcList().size());		assertEquals(new Long(0x45), byePacket.getSsrcList().get(0));		assertEquals(new Long(0x46), byePacket.getSsrcList().get(1));		assertEquals("So long, cruel world.", byePacket.getReasonForLeaving());		// Size without fixed block size would be 36 so padding is 64 - 36		assertEquals(64 - 36, bufferArray[bufferArray.length - 1]);		assertEquals(0, buffer.capacity() - buffer.position());	}	@Test	public void testEncodeDecodeWithFixedBlockSize64AndCompound() throws Exception {		ByePacket packet = new ByePacket();		packet.addSsrc(0x45);		packet.addSsrc(0x46);		packet.setReasonForLeaving("So long, cruel world.");		ByteBufferManager mm = new ByteBufferManager();		Buffer buffer = packet.encode(60, 64, mm);		// Alignment would be to 128 bytes *with* the other RTCP packets. So		// this packet is sized at 128 - 60 = 68		assertEquals(68, buffer.capacity());		byte[] bufferArray = buffer.array();		System.out.println(ByteUtils.writeArrayAsHex(bufferArray, true));		assertEquals(0, buffer.capacity() % 4);		buffer.position(0);		ControlPacket controlPacket = ControlPacket.decode(buffer);		assertEquals(ControlPacket.Type.BYE, controlPacket.getType());		ByePacket byePacket = (ByePacket) controlPacket;		assertNotNull(byePacket.getSsrcList());		assertEquals(2, byePacket.getSsrcList().size());		assertEquals(new Long(0x45), byePacket.getSsrcList().get(0));		assertEquals(new Long(0x46), byePacket.getSsrcList().get(1));		assertEquals("So long, cruel world.", byePacket.getReasonForLeaving());		// Size without fixed block size would be 36 so padding is 128 - (60 +		// 36) because current compound length is 60		assertEquals(128 - (60 + 36), bufferArray[bufferArray.length - 1]);		assertEquals(0, buffer.capacity() - buffer.position());	}}